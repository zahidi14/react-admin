{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useCallback } from 'react';\nimport merge from 'lodash/merge';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport useDataProviderWithDeclarativeSideEffects from './useDataProviderWithDeclarativeSideEffects';\n/**\n * Get a callback to fetch the data provider through Redux, usually for mutations.\n *\n * The request starts when the callback is called.\n *\n * useMutation() parameters can be passed:\n *\n * - at definition time\n *\n *       const [mutate] = useMutation(query, options); mutate();\n *\n * - at call time\n *\n *       const [mutate] = useMutation(); mutate(query, options);\n *\n * - both, in which case the definition and call time parameters are merged\n *\n *       const [mutate] = useMutation(query1, options1); mutate(query2, options2));\n *\n * @param {Object} query\n * @param {string} query.type The method called on the data provider, e.g. 'getList', 'getOne'. Can also be a custom method if the dataProvider supports is.\n * @param {string} query.resource A resource name, e.g. 'posts', 'comments'\n * @param {Object} query.payload The payload object, e.g; { post_id: 12 }\n * @param {Object} options\n * @param {string} options.action Redux action type\n * @param {boolean} options.undoable Set to true to run the mutation locally before calling the dataProvider\n * @param {Function} options.onSuccess Side effect function to be executed upon success of failure, e.g. { onSuccess: response => refresh() } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) } }\n * @param {boolean} options.withDeclarativeSideEffectsSupport Set to true to support legacy side effects (e.g. { onSuccess: { refresh: true } })\n *\n * @returns A tuple with the mutation callback and the request state. Destructure as [mutate, { data, total, error, loading, loaded }].\n *\n * The return value updates according to the request state:\n *\n * - mount:         [mutate, { loading: false, loaded: false }]\n * - mutate called: [mutate, { loading: true, loaded: false }]\n * - success:       [mutate, { data: [data from response], total: [total from response], loading: false, loaded: true }]\n * - error:         [mutate, { error: [error from response], loading: false, loaded: true }]\n *\n * The mutate function accepts the following arguments\n * - {Object} query\n * - {string} query.type The method called on the data provider, e.g. 'update'\n * - {string} query.resource A resource name, e.g. 'posts', 'comments'\n * - {Object} query.payload The payload object, e.g. { id: 123, data: { isApproved: true } }\n * - {Object} options\n * - {string} options.action Redux action type\n * - {boolean} options.undoable Set to true to run the mutation locally before calling the dataProvider\n * - {Function} options.onSuccess Side effect function to be executed upon success of failure, e.g. { onSuccess: response => refresh() } }\n * - {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) } }\n * - {boolean} withDeclarativeSideEffectsSupport Set to true to support legacy side effects (e.g. { onSuccess: { refresh: true } })\n *\n * @example\n *\n * // pass parameters at definition time\n * // use when all parameters are determined at definition time\n * // the mutation callback can be used as an even handler\n * // because Event parameters are ignored\n * import { useMutation } from 'react-admin';\n *\n * const ApproveButton = ({ record }) => {\n *     const [approve, { loading }] = useMutation({\n *         type: 'update',\n *         resource: 'comments',\n *         payload: { id: record.id, data: { isApproved: true } }\n *     });\n *     return <Button label=\"Approve\" onClick={approve} disabled={loading} />;\n * };\n *\n * @example\n *\n * // pass parameters at call time\n * // use when some parameters are only known at call time\n * import { useMutation } from 'react-admin';\n *\n * const ApproveButton = ({ record }) => {\n *     const [mutate, { loading }] = useMutation();\n *     const approve = event => mutate({\n *         type: 'update',\n *         resource: 'comments',\n *         payload: {\n *             id: event.target.dataset.id,\n *             data: { isApproved: true, updatedAt: new Date() }\n *         },\n *     });\n *     return <Button\n *         label=\"Approve\"\n *         onClick={approve}\n *         disabled={loading}\n *     />;\n * };\n *\n * @example\n *\n * // use the second argument to pass options\n * import { useMutation, useNotify, CRUD_UPDATE } from 'react-admin';\n *\n * const ResetStockButton = ({ record }) => {\n *     const [mutate, { loading }] = useMutation();\n *     const notify = useNotify();\n *     const handleClick = () => mutate(\n *         {\n *              type: 'update',\n *              resource: 'items',\n *              payload: { id: record.id, data: { stock: 0 } }\n *         },\n *         {\n *              undoable: true,\n *              action: CRUD_UPDATE,\n *              onSuccess: response => notify('Success !'),\n *              onFailure: error => notify('Failure !')\n *         }\n *     );\n *     return <Button label=\"Reset stock\" onClick={handleClick} disabled={loading} />;\n * };\n */\n\nvar useMutation = function (query, options) {\n  var _a = useSafeSetState({\n    data: null,\n    error: null,\n    total: null,\n    loading: false,\n    loaded: false\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  var dataProvider = useDataProvider();\n  var dataProviderWithDeclarativeSideEffects = useDataProviderWithDeclarativeSideEffects();\n  /* eslint-disable react-hooks/exhaustive-deps */\n\n  var mutate = useCallback(function (callTimeQuery, callTimeOptions) {\n    var finalDataProvider = hasDeclarativeSideEffectsSupport(options, callTimeOptions) ? dataProviderWithDeclarativeSideEffects : dataProvider;\n    var params = mergeDefinitionAndCallTimeParameters(query, callTimeQuery, options, callTimeOptions);\n    setState(function (prevState) {\n      return __assign({}, prevState, {\n        loading: true\n      });\n    });\n    finalDataProvider[params.type](params.resource, params.payload, params.options).then(function (_a) {\n      var data = _a.data,\n          total = _a.total;\n      setState({\n        data: data,\n        total: total,\n        loading: false,\n        loaded: true\n      });\n    }).catch(function (errorFromResponse) {\n      setState({\n        error: errorFromResponse,\n        loading: false,\n        loaded: false\n      });\n    });\n  }, [// deep equality, see https://github.com/facebook/react/issues/14476#issuecomment-471199055\n  JSON.stringify({\n    query: query,\n    options: options\n  }), dataProvider, dataProviderWithDeclarativeSideEffects, setState]\n  /* eslint-enable react-hooks/exhaustive-deps */\n  );\n  return [mutate, state];\n};\n/**\n * Utility function for merging parameters\n *\n * useMutation() parameters can be passed:\n * - at definition time (e.g. useMutation({ type: 'update', resource: 'posts', payload: { id: 1, data: { title: '' } } }) )\n * - at call time (e.g [mutate] = useMutation(); mutate({ type: 'update', resource: 'posts', payload: { id: 1, data: { title: '' } } }))\n * - both\n *\n * This function merges the definition time and call time parameters.\n *\n * This is useful because useMutation() is used by higher-level hooks like\n * useCreate() or useUpade(), and these hooks can be called both ways.\n * So it makes sense to make useMutation() capable of handling both call types\n * as it avoids repetition higher in the hook chain.\n *\n * Also, the call time query may be a DOM Event if the callback is used\n * as an event listener, as in:\n *\n * const UpdateButton = () => {\n *     const mutate = useMutation({ type: 'update', resource: 'posts', payload: { id: 1, data: { title: '' } } });\n *     return <button onclick={mutate}>Click me</button>\n * };\n *\n * This usage is accepted, and therefore this function checks if the call time\n * query is an Event, and discards it in that case.\n *\n * @param query {Mutation}\n * @param callTimeQuery {Mutation}\n * @param options {Object}\n * @param callTimeOptions {Object}\n *\n * @return { type, resource, payload, options } The merged parameters\n */\n\n\nvar mergeDefinitionAndCallTimeParameters = function (query, callTimeQuery, options, callTimeOptions) {\n  if (!query && (!callTimeQuery || callTimeQuery instanceof Event)) {\n    throw new Error('Missing query either at definition or at call time');\n  }\n\n  if (callTimeQuery instanceof Event) return {\n    type: query.type,\n    resource: query.resource,\n    payload: query.payload,\n    options: sanitizeOptions(options)\n  };\n  if (query) return {\n    type: query.type || callTimeQuery.type,\n    resource: query.resource || callTimeQuery.resource,\n    payload: callTimeQuery ? merge({}, query.payload, callTimeQuery.payload) : query.payload,\n    options: callTimeOptions ? merge({}, sanitizeOptions(options), sanitizeOptions(callTimeOptions)) : sanitizeOptions(options)\n  };\n  return {\n    type: callTimeQuery.type,\n    resource: callTimeQuery.resource,\n    payload: callTimeQuery.payload,\n    options: sanitizeOptions(callTimeOptions)\n  };\n};\n\nvar hasDeclarativeSideEffectsSupport = function (options, callTimeOptions) {\n  if (!options && !callTimeOptions) return false;\n  if (callTimeOptions && callTimeOptions.withDeclarativeSideEffectsSupport) return true;\n  if (options && options.withDeclarativeSideEffectsSupport) return true;\n  return false;\n};\n\nvar sanitizeOptions = function (args) {\n  if (!args) return {};\n\n  var withDeclarativeSideEffectsSupport = args.withDeclarativeSideEffectsSupport,\n      options = __rest(args, [\"withDeclarativeSideEffectsSupport\"]);\n\n  return options;\n};\n\nexport default useMutation;","map":null,"metadata":{},"sourceType":"module"}