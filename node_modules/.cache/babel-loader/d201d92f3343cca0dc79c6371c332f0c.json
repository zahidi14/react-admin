{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useMemo, useState, useEffect, useRef } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport difference from 'lodash/difference';\nimport { useGetMany } from '../../dataProvider';\nimport useGetMatching from '../../dataProvider/useGetMatching';\nimport { useTranslate } from '../../i18n';\nimport { getStatusForArrayInput as getDataStatus } from './referenceDataStatus';\n/**\n * Prepare data for the ReferenceArrayInput components\n *\n * @example\n *\n * const { choices, error, loaded, loading } = useReferenceArrayInputController({\n *      basePath: 'resource';\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} option\n * @param {boolean} option.allowEmpty do we allow for no referenced record (default to false)\n * @param {string} option.basePath basepath to current resource\n * @param {string | false} option.linkType The type of the link toward the referenced record. edit, show of false for no link (default to edit)\n * @param {Object} option.record The The current resource record\n * @param {string} option.reference The linked resource name\n * @param {string} option.resource The current resource name\n * @param {string} option.source The key of the linked resource identifier\n *\n * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components\n */\n\nvar useReferenceArrayInputController = function (_a) {\n  var defaultFilter = _a.filter,\n      _b = _a.filterToQuery,\n      filterToQuery = _b === void 0 ? defaultFilterToQuery : _b,\n      input = _a.input,\n      _c = _a.perPage,\n      perPage = _c === void 0 ? 25 : _c,\n      _d = _a.sort,\n      defaultSort = _d === void 0 ? {\n    field: 'id',\n    order: 'DESC'\n  } : _d,\n      options = _a.options,\n      reference = _a.reference,\n      resource = _a.resource,\n      source = _a.source;\n  var translate = useTranslate(); // We store the current input value in a ref so that we are able to fetch\n  // only the missing references when the input value changes\n\n  var inputValue = useRef(input.value);\n\n  var _e = useState(input.value),\n      idsToFetch = _e[0],\n      setIdsToFetch = _e[1];\n\n  useEffect(function () {\n    var newIdsToFetch = difference(input.value, inputValue.current);\n\n    if (newIdsToFetch.length > 0) {\n      setIdsToFetch(newIdsToFetch);\n    }\n\n    inputValue.current = input.value;\n  }, [input.value, setIdsToFetch]);\n\n  var _f = useState({\n    page: 1,\n    perPage: perPage\n  }),\n      pagination = _f[0],\n      setPagination = _f[1];\n\n  var _g = useState(defaultSort),\n      sort = _g[0],\n      setSort = _g[1];\n\n  var _h = useState(''),\n      filter = _h[0],\n      setFilter = _h[1]; // Ensure sort can be updated through props too, not just by using the setSort function\n\n\n  useEffect(function () {\n    if (!isEqual(defaultSort, sort)) {\n      setSort(defaultSort);\n    }\n  }, [setSort, defaultSort, sort]); // Ensure pagination can be updated through props too, not just by using the setPagination function\n\n  useEffect(function () {\n    var newPagination = {\n      page: 1,\n      perPage: perPage\n    };\n\n    if (!isEqual(newPagination, pagination)) {\n      setPagination(newPagination);\n    }\n  }, [setPagination, perPage, pagination]); // Merge the user filters with the default ones\n\n  var finalFilter = useMemo(function () {\n    return __assign({}, defaultFilter, filterToQuery(filter));\n  }, [defaultFilter, filter, filterToQuery]);\n\n  var _j = useGetMany(reference, idsToFetch || []),\n      referenceRecords = _j.data,\n      loaded = _j.loaded;\n\n  var matchingReferences = useGetMatching(reference, pagination, sort, finalFilter, source, resource, options).data; // filter out not found references - happens when the dataProvider doesn't guarantee referential integrity\n\n  var finalReferenceRecords = referenceRecords ? referenceRecords.filter(Boolean) : []; // We merge the currently selected records with the matching ones, otherwise\n  // the component displaying the currently selected records may fail\n\n  var finalMatchingReferences = matchingReferences && matchingReferences.length > 0 ? mergeReferences(matchingReferences, finalReferenceRecords) : finalReferenceRecords.length > 0 ? finalReferenceRecords : matchingReferences;\n  var dataStatus = getDataStatus({\n    input: input,\n    matchingReferences: finalMatchingReferences,\n    referenceRecords: finalReferenceRecords,\n    translate: translate\n  });\n  return {\n    choices: dataStatus.choices,\n    error: dataStatus.error,\n    loaded: loaded,\n    loading: dataStatus.waiting,\n    setFilter: setFilter,\n    setPagination: setPagination,\n    setSort: setSort,\n    warning: dataStatus.warning\n  };\n}; // concatenate and deduplicate two lists of records\n\n\nvar mergeReferences = function (ref1, ref2) {\n  var res = ref1.slice();\n  var ids = ref1.map(function (ref) {\n    return ref.id;\n  });\n  ref2.forEach(function (ref) {\n    if (!ids.includes(ref.id)) {\n      ids.push(ref.id);\n      res.push(ref);\n    }\n  });\n  return res;\n};\n\nexport default useReferenceArrayInputController;\n\nvar defaultFilterToQuery = function (searchText) {\n  return {\n    q: searchText\n  };\n};","map":null,"metadata":{},"sourceType":"module"}