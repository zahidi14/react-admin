{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useEffect } from 'react';\nimport { useSelector } from 'react-redux';\nimport isEqual from 'lodash/isEqual';\nimport useDataProvider from './useDataProvider';\nimport getFetchType from './getFetchType';\nimport { useSafeSetState } from '../util/hooks';\n/**\n * Lists of records are initialized to a particular object,\n * so detecting if the list is empty requires some work.\n *\n * @see src/reducer/admin/data.ts\n */\n\nvar isEmptyList = function (data) {\n  return Array.isArray(data) ? data.length === 0 : data && Object.keys(data).length === 0 && data.hasOwnProperty('fetchedAt');\n};\n/**\n * Default cache selector. Allows to cache responses by default.\n *\n * By default, custom queries are dispatched as a CUSTOM_QUERY Redux action.\n * The useDataProvider hookdispatches a CUSTOM_QUERY_SUCCESS when the response\n * comes, and the customQueries reducer stores the result in the store.\n * This selector reads the customQueries store and acts as a response cache.\n */\n\n\nvar defaultDataSelector = function (query) {\n  return function (state) {\n    var key = JSON.stringify(__assign({}, query, {\n      type: getFetchType(query.type)\n    }));\n    return state.admin.customQueries[key] ? state.admin.customQueries[key].data : undefined;\n  };\n};\n\nvar defaultTotalSelector = function () {\n  return null;\n};\n/**\n * Fetch the data provider through Redux, return the value from the store.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false }\n * - success: { data: [data from response], total: [total from response], loading: false, loaded: true }\n * - error: { error: [error from response], loading: false, loaded: true }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {Object} query\n * @param {string} query.type The verb passed to th data provider, e.g. 'getList', 'getOne'\n * @param {string} query.resource A resource name, e.g. 'posts', 'comments'\n * @param {Object} query.payload The payload object, e.g; { post_id: 12 }\n * @param {Object} options\n * @param {string} options.action Redux action type\n * @param {Function} options.onSuccess Side effect function to be executed upon success of failure, e.g. { onSuccess: response => refresh() } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) } }\n * @param {function} dataSelector Redux selector to get the result. Required.\n * @param {function} totalSelector Redux selector to get the total (optional, only for LIST queries)\n *\n * @returns The current request state. Destructure as { data, total, error, loading, loaded }.\n *\n * @example\n *\n * import { useQueryWithStore } from 'react-admin';\n *\n * const UserProfile = ({ record }) => {\n *     const { data, loading, error } = useQueryWithStore(\n *         {\n *             type: 'getOne',\n *             resource: 'users',\n *             payload: { id: record.id }\n *         },\n *         {},\n *         state => state.admin.resources.users.data[record.id]\n *     );\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\n\n\nvar useQueryWithStore = function (query, options, dataSelector, totalSelector) {\n  if (options === void 0) {\n    options = {\n      action: 'CUSTOM_QUERY'\n    };\n  }\n\n  if (dataSelector === void 0) {\n    dataSelector = defaultDataSelector(query);\n  }\n\n  if (totalSelector === void 0) {\n    totalSelector = defaultTotalSelector;\n  }\n\n  var type = query.type,\n      resource = query.resource,\n      payload = query.payload;\n  var data = useSelector(dataSelector);\n  var total = useSelector(totalSelector);\n\n  var _a = useSafeSetState({\n    data: data,\n    total: total,\n    error: null,\n    loading: true,\n    loaded: data !== undefined && !isEmptyList(data)\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  if (!isEqual(state.data, data) || state.total !== total) {\n    setState(__assign({}, state, {\n      data: data,\n      total: total,\n      loaded: true\n    }));\n  }\n\n  var dataProvider = useDataProvider();\n  useEffect(function () {\n    setState(function (prevState) {\n      return __assign({}, prevState, {\n        loading: true\n      });\n    });\n    dataProvider[type](resource, payload, options).then(function () {\n      // We don't care about the dataProvider response here, because\n      // it was already passed to SUCCESS reducers by the dataProvider\n      // hook, and the result is available from the Redux store\n      // through the data and total selectors.\n      // In addition, if the query is optimistic, the response\n      // will be empty, so it should not be used at all.\n      setState(function (prevState) {\n        return __assign({}, prevState, {\n          error: null,\n          loading: false,\n          loaded: true\n        });\n      });\n    }).catch(function (error) {\n      setState({\n        error: error,\n        loading: false,\n        loaded: false\n      });\n    }); // deep equality, see https://github.com/facebook/react/issues/14476#issuecomment-471199055\n  }, [JSON.stringify({\n    query: query,\n    options: options\n  })]); // eslint-disable-line\n\n  return state;\n};\n\nexport default useQueryWithStore;","map":null,"metadata":{},"sourceType":"module"}