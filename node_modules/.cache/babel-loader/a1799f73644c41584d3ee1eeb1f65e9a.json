{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { Children, useCallback, isValidElement, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport { Form } from 'react-final-form';\nimport arrayMutators from 'final-form-arrays';\nimport { Route } from 'react-router-dom';\nimport Divider from '@material-ui/core/Divider';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { useTranslate, useInitializeFormWithRecord, sanitizeEmptyValues } from 'ra-core';\nimport get from 'lodash/get';\nimport getFormInitialValues from './getFormInitialValues';\nimport Toolbar from './Toolbar';\nimport TabbedFormTabs, { getTabFullPath } from './TabbedFormTabs';\nimport { useRouteMatch, useLocation } from 'react-router-dom';\nvar useStyles = makeStyles(function (theme) {\n  return {\n    errorTabButton: {\n      color: theme.palette.error.main\n    },\n    content: {\n      paddingTop: theme.spacing(1),\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2)\n    }\n  };\n});\n\nvar TabbedForm = function (_a) {\n  var initialValues = _a.initialValues,\n      defaultValue = _a.defaultValue,\n      saving = _a.saving,\n      props = __rest(_a, [\"initialValues\", \"defaultValue\", \"saving\"]);\n\n  var redirect = useRef(props.redirect); // We don't use state here for two reasons:\n  // 1. There no way to execute code only after the state has been updated\n  // 2. We don't want the form to rerender when redirect is changed\n\n  var setRedirect = function (newRedirect) {\n    redirect.current = newRedirect;\n  };\n\n  var translate = useTranslate();\n  var classes = useStyles();\n  var finalInitialValues = getFormInitialValues(initialValues, defaultValue, props.record);\n\n  var submit = function (values) {\n    var finalRedirect = typeof redirect.current === undefined ? props.redirect : redirect.current;\n    var finalValues = sanitizeEmptyValues(finalInitialValues, values);\n    props.save(finalValues, finalRedirect);\n  };\n\n  return React.createElement(Form, __assign({\n    key: props.version,\n    initialValues: finalInitialValues,\n    onSubmit: submit,\n    mutators: __assign({}, arrayMutators),\n    setRedirect: setRedirect,\n    keepDirtyOnReinitialize: true,\n    subscription: defaultSubscription\n  }, props, {\n    render: function (formProps) {\n      return React.createElement(TabbedFormView, __assign({\n        classes: classes,\n        saving: formProps.submitting || saving,\n        translate: translate\n      }, props, formProps));\n    }\n  }));\n};\n\nvar defaultSubscription = {\n  submitting: true,\n  pristine: true,\n  valid: true,\n  invalid: true\n};\nexport default TabbedForm;\nexport var TabbedFormView = function (_a) {\n  var basePath = _a.basePath,\n      children = _a.children,\n      className = _a.className,\n      _b = _a.classes,\n      classes = _b === void 0 ? {} : _b,\n      form = _a.form,\n      handleSubmit = _a.handleSubmit,\n      invalid = _a.invalid,\n      pristine = _a.pristine,\n      record = _a.record,\n      defaultRedirect = _a.redirect,\n      resource = _a.resource,\n      saving = _a.saving,\n      setRedirect = _a.setRedirect,\n      submitOnEnter = _a.submitOnEnter,\n      tabs = _a.tabs,\n      toolbar = _a.toolbar,\n      translate = _a.translate,\n      undoable = _a.undoable,\n      value = _a.value,\n      version = _a.version,\n      variant = _a.variant,\n      margin = _a.margin,\n      rest = __rest(_a, [\"basePath\", \"children\", \"className\", \"classes\", \"form\", \"handleSubmit\", \"invalid\", \"pristine\", \"record\", \"redirect\", \"resource\", \"saving\", \"setRedirect\", \"submitOnEnter\", \"tabs\", \"toolbar\", \"translate\", \"undoable\", \"value\", \"version\", \"variant\", \"margin\"]);\n\n  useInitializeFormWithRecord(record);\n  var handleSubmitWithRedirect = useCallback(function (redirect) {\n    if (redirect === void 0) {\n      redirect = defaultRedirect;\n    }\n\n    setRedirect(redirect);\n    handleSubmit();\n  }, [setRedirect, defaultRedirect, handleSubmit]);\n  var tabsWithErrors = findTabsWithErrors(children, form.getState().errors);\n  var match = useRouteMatch();\n  var location = useLocation();\n  var url = match ? match.url : location.pathname;\n  return React.createElement(\"form\", __assign({\n    className: classnames('tabbed-form', className),\n    key: version\n  }, sanitizeRestProps(rest)), React.cloneElement(tabs, {\n    classes: classes,\n    url: url,\n    tabsWithErrors: tabsWithErrors\n  }, children), React.createElement(Divider, null), React.createElement(\"div\", {\n    className: classes.content\n  }, Children.map(children, function (tab, index) {\n    return tab && React.createElement(Route, {\n      exact: true,\n      path: getTabFullPath(tab, index, url)\n    }, function (routeProps) {\n      return isValidElement(tab) ? React.cloneElement(tab, {\n        intent: 'content',\n        resource: resource,\n        record: record,\n        basePath: basePath,\n        hidden: !routeProps.match,\n        variant: variant,\n        margin: margin\n      }) : null;\n    });\n  })), toolbar && React.cloneElement(toolbar, {\n    basePath: basePath,\n    className: 'toolbar',\n    handleSubmitWithRedirect: handleSubmitWithRedirect,\n    handleSubmit: handleSubmit,\n    invalid: invalid,\n    pristine: pristine,\n    record: record,\n    redirect: defaultRedirect,\n    resource: resource,\n    saving: saving,\n    submitOnEnter: submitOnEnter,\n    undoable: undoable\n  }));\n};\nTabbedFormView.propTypes = {\n  basePath: PropTypes.string,\n  children: PropTypes.node,\n  className: PropTypes.string,\n  classes: PropTypes.object,\n  defaultValue: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n  initialValues: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n  handleSubmit: PropTypes.func,\n  invalid: PropTypes.bool,\n  location: PropTypes.object,\n  match: PropTypes.object,\n  pristine: PropTypes.bool,\n  record: PropTypes.object,\n  redirect: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.func]),\n  resource: PropTypes.string,\n  save: PropTypes.func,\n  saving: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),\n  submitOnEnter: PropTypes.bool,\n  tabs: PropTypes.element.isRequired,\n  tabsWithErrors: PropTypes.arrayOf(PropTypes.string),\n  toolbar: PropTypes.element,\n  translate: PropTypes.func,\n  undoable: PropTypes.bool,\n  validate: PropTypes.func,\n  value: PropTypes.number,\n  version: PropTypes.number\n};\nTabbedFormView.defaultProps = {\n  submitOnEnter: true,\n  tabs: React.createElement(TabbedFormTabs, null),\n  toolbar: React.createElement(Toolbar, null)\n};\n\nvar sanitizeRestProps = function (_a) {\n  var anyTouched = _a.anyTouched,\n      array = _a.array,\n      asyncBlurFields = _a.asyncBlurFields,\n      asyncValidate = _a.asyncValidate,\n      asyncValidating = _a.asyncValidating,\n      autofill = _a.autofill,\n      blur = _a.blur,\n      change = _a.change,\n      clearAsyncError = _a.clearAsyncError,\n      clearFields = _a.clearFields,\n      clearSubmit = _a.clearSubmit,\n      clearSubmitErrors = _a.clearSubmitErrors,\n      destroy = _a.destroy,\n      dirty = _a.dirty,\n      dirtyFields = _a.dirtyFields,\n      dirtyFieldsSinceLastSubmit = _a.dirtyFieldsSinceLastSubmit,\n      dirtySinceLastSubmit = _a.dirtySinceLastSubmit,\n      dispatch = _a.dispatch,\n      form = _a.form,\n      handleSubmit = _a.handleSubmit,\n      hasSubmitErrors = _a.hasSubmitErrors,\n      hasValidationErrors = _a.hasValidationErrors,\n      initialize = _a.initialize,\n      initialized = _a.initialized,\n      initialValues = _a.initialValues,\n      pristine = _a.pristine,\n      pure = _a.pure,\n      redirect = _a.redirect,\n      reset = _a.reset,\n      resetSection = _a.resetSection,\n      save = _a.save,\n      staticContext = _a.staticContext,\n      submit = _a.submit,\n      submitAsSideEffect = _a.submitAsSideEffect,\n      submitError = _a.submitError,\n      submitErrors = _a.submitErrors,\n      submitFailed = _a.submitFailed,\n      submitSucceeded = _a.submitSucceeded,\n      submitting = _a.submitting,\n      touch = _a.touch,\n      translate = _a.translate,\n      triggerSubmit = _a.triggerSubmit,\n      undoable = _a.undoable,\n      untouch = _a.untouch,\n      valid = _a.valid,\n      validate = _a.validate,\n      validating = _a.validating,\n      _reduxForm = _a._reduxForm,\n      props = __rest(_a, [\"anyTouched\", \"array\", \"asyncBlurFields\", \"asyncValidate\", \"asyncValidating\", \"autofill\", \"blur\", \"change\", \"clearAsyncError\", \"clearFields\", \"clearSubmit\", \"clearSubmitErrors\", \"destroy\", \"dirty\", \"dirtyFields\", \"dirtyFieldsSinceLastSubmit\", \"dirtySinceLastSubmit\", \"dispatch\", \"form\", \"handleSubmit\", \"hasSubmitErrors\", \"hasValidationErrors\", \"initialize\", \"initialized\", \"initialValues\", \"pristine\", \"pure\", \"redirect\", \"reset\", \"resetSection\", \"save\", \"staticContext\", \"submit\", \"submitAsSideEffect\", \"submitError\", \"submitErrors\", \"submitFailed\", \"submitSucceeded\", \"submitting\", \"touch\", \"translate\", \"triggerSubmit\", \"undoable\", \"untouch\", \"valid\", \"validate\", \"validating\", \"_reduxForm\"]);\n\n  return props;\n};\n\nexport var findTabsWithErrors = function (children, errors) {\n  return Children.toArray(children).reduce(function (acc, child) {\n    if (!isValidElement(child)) {\n      return acc;\n    }\n\n    var inputs = Children.toArray(child.props.children);\n\n    if (inputs.some(function (input) {\n      return isValidElement(input) && get(errors, input.props.source);\n    })) {\n      return acc.concat([child.props.label]);\n    }\n\n    return acc;\n  }, []);\n};","map":null,"metadata":{},"sourceType":"module"}